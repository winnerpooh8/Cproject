# Cproject
 2025-02-08~2025-03-15 project
 
## 목차
[깃허브 데스크톱](#깃허브-데스크톱)
<hr/>

# 깃허브 데스크톱

+ 설치방법
 > https://desktop.github.com/download/

<hr/>

# 코드 기본 구성
+ 전처리기
+ main
```c
# include <stdio.h>

int main()
{
  printf("C programming");
  return 0;
}
```

# printf
> stdio.h에서 제공해주는 c언어의 대표적인 문장 출력용 기능(함수)입니다.<br>
> 일반적으로는 printf("작성하고 싶은 문장");을 작성해 사용합니다.

예시)
```c
# include <stdio.h>

int main()
{
  printf("C programming");
  return 0;
}
```

# 서식지정자
|지정자 명칭|설명|
|-----|-----|
|%d|정수에 대한 지정자|
|%f|실수에 대한 지정자|
|%c|문자에 대한 지정자|

<hr/>

# 이스케이프 시퀀스
> 프로르래밍 언어 특성 상 표현이 불가능한 기능, 문자에 대한 표현
> \ + 영단어 소문자 1개로 구성되어 있습니다.
>  <자주 사용되는 종류>
>  \n : Enter키, \t : Tab키, \": "에 대한 표현, \': '에 대한 표현


<hr/>

# 데이터 표현법(리터럴literal) -> 순수한값
+ 리터럴은 C언어에서 데이터를 표기하는 방법이며 값을 그대로 입력한 것을 의미합니다.
+ 정수의 경우 그대로 입력 예) 10
+ 실수의 경우 마지막에 f를 붙여줍니다. 예)10.0f
+ 문자의 경우에는 작은따옴표 안에 작성합니다. 예)'a'
+ 문장의 경우에는 큰따옴표 안에 작성합니다. 예)"apple)

  
<hr/>

# 변수
+ (C언어에서 특정 하나의 데이터를 사용자가 이름지어서 저장하는 방법(공간)
> <변수에 저장되어있는 데이터의 값은 일반적으로 언제든지 변경이 가능합니다.>
> C언어에서의 변수는 변수마다 정해진 데이터의 형태(자료형)이존재하며,
  각변수는할당된 값을 가지고 있습니다.

<hr/>

+ 변수를 만들 때 지켜줄 이름 규칙
	> 1. 대소문자를 구분합니다.
	> 2. 변수의 이름은 숫자가 맨 앞에 나올 수 없습니다. 
	> 3. 변수의 이름에 특수문자 사용이 불가능합니다.(예외) _, $는 C언어에서 변수 이름으로 사용가능)
	> 4. 변수의 이름으로 키워드를 사용할 수 없습니다.

+ 변수에 대한 선언
 > 자료형 변수명
예) int count;

 + 변수를 선언할 경우 자료형의 크기만큼 메모리 공간을 확보하여 그 위치에 변수의 이름을 지정하게 됩니다.
 > 예) count = 5;

 + 데이터의 형태가 같다면, 여러개를 한번에 선언 할 수 있습니다.
		> int a, b, c;

 + 변수에 대한 초기화
> 변수명 = 타입에 맞는 값

+ 변수의 이름과 초기화를 동시에 진행할 수 있습니다.
	> float PI = 3.141592f;
 
 +선언과 초기화를 통시에 여러개를 진행 할 수 있습니다.
		> int number3 = 50, number4 = 40;
  
	+ C언어에서 10진수 이외의 8진수나 16진수를 지정할 수 있습니다.
	> int octo = 15; // 숫자 앞에 0이 붙으면 8진수
	> int hexa = 0x6; //숫자앞에 0x가 붙으면 16진수
 
<hr/>


# 자료형(Type)
> 프로그램이 데이터를 판단하는 기준, 데이터의 형태를 의미합니다.
> 대표적인 자료형
> 이름 표현하는 형태 크기    표현범위 
+ int   정수       4byte   -2147483648~217483647
+ float  실수       4byte   3.4 * 10 -38 ~ 3.4 * 10 +38제곱 --> 소수점 이하 6자리까지 정확하게 표현
+ char   문자       1byte   -128 ~ 127

# 입력(input)
+ 사용자가 직접 값을 입력하고 그 값을, 특정 위치에 전달합니다.
+ 일반적으로 변수를 만들고, 그 변수에 입력한 값을 적용하는 방식으로 사용됩니다.

# getchar()
+ 키보드로부터 하나의 문자를 읽어내는 함수
+ 이 기능은 입력 버퍼를 비우는 용도로도 사용됩니다.
>입력버퍼(buffer) : C언어에서 입력을 진행할 경우 바로 값을 넘기는게 아니라
>임시로 데이터를 저장하는 별도의 공간에 값을 넣고 전달하는 방식입니다.
>문자를 다 받기 때문에 enter같은 기능도 값으로 남게 됩니다.

# putchar(문자)_
+ 전달받은 문자 하나를 화면에 출력하는 기능

# gets(), puts()
+ 문자열에 대한 입력과출력을 진행할때 편하게 사용할 수 있습니다.
+ 문자열(문장)이랑 char 형태의 데이터를 묶음으로 표현한 것을 의미합니다.
  
# 문자열 만드는 방법
+ char 변수명[문자의 개수]
    >char word[10];
    
+ gets(word); -> 문자열 출력

+ puts(word); -> 전달한 문장 출력

+ 주의사항 :
> C언어에서 한글을 입력하는 경우 한글 한 단어당에 2칸을 소모합니다.
> 현재 word는 10개의 단어를 사용할 수 있습니다.
> 한글을 기준으로 5개의 단어까지 입력이 가능합니다.
> 단 입력을 진행할 경우 문자의 개수보자 1개정도 적게 작성합니다.
> 따라서 영단어는 9글자까지, 한글은 4글자 까지 가능

<hr/>

# 연산자(operator)
> 프로그램에서 연산을 진행할 때 사용하는 기호
> ex) 10 + 5 라고 할 때 연산자는 +

<hr/>

+ 산술연산자
  + ,    - ,   * ,     /  ,   %
더하기, 빼기, 곱하기, 나누기, 나머지

<hr/>

+ 대입 연산자
> = 을 이용해 값을 대입할 수 있습니다.
> ex) a = 5라고 하면 a에 5의 값을 대입합니다

<hr/>

+ 혼합 대입 연산자
> = 전에 +,-,*,%를 작성하는 경우 대입하려는 값에 연산을 진행한 결과를 대입합니다.
> ex) 위의 코드에서 추가적으로 다음과 같이 명령을 작성합니다.
>> a += 5;라고 적으면 a에 5를 더한 결과를 a에 대입합니다. 따라서 10이 됩니다.
>> 즉 a += 5는 a = a + 5와 같은 말입니다.

<hr/>

+ 증감 연산자
> 변수의 값을 1 증가 / 감소 시킬 때 사용하는 연산자(단항)
>> ++, --

<hr/>

+ 관계연산자
> 연산자를 기준으로 왼쪽과 오른쪽 값의 크기를 비교해서 참 또는 거짓을 확인합니다.
> 참일 경우 1을 거짓일 경우 0으로 처리됩니다.

<hr/>

+ if(조건식)
> {조건식이 만족할 때, 실행할 명령문}
> 1. if (a > b)
>> {printf("a는 b보다 큰 값입니다.\n");}
> 2. if (a >= b)
>> {printf("a는 b보다 크거나 같습니다.\n");}
> 3. if(a == b) //a와 b의 크기가 동일한지를 확인합니다.
>> {printf("a는 b와 같습니다.\n");}
> 4. if (a != b)//a와 b가 서로 다른 경우를 확인합니다.
>> {printf("a는 b와 다릅니다.\n");}

<hr/>

+ a & b;  a AND b   --> 교집합

<hr/>

+ a | b;  a OR b    --> 합집합

<hr/>

+ XOR(Exclusive OR) : 배타적 논리합, 대칭 차집합
> a와 b를 비교했을 때 비트가 다른 지점을 1, 같으면 0으로 처리합니다.
>> 이 연산 방식은 암호학의 기초로 많이 활용됩니다.

<hr/>

+ NOT 연산(~)
> 비트를 반대로 처리하는 연산

<hr/>

+ shift 연산(<<,>>)
> a << 2 일 경우 a를 비트 2칸 이동합니다. 비트 2칸은 2의 2제곱(4)를 의미하니
>> a * 4로 해석이 가능합니다.

<hr/>

+ 비트 연산(bitwise)
> 데이터를 비트 단위로 처리하는 연산자입니다.
> 컴퓨터는 데이터를 2진 코드로 관리합니다.(이진수)

+ 비트 연산 사용 목적
> 1. 곱하기와 나누기 연산을 더 빠르게 진행할 수 있습니다.
> 2. 프로그램에서 이미지 처리하는 작업(ex. RGB 값 분리, 결합, 픽셀 값 조작)
> 3. 데이터를 압축하는 작업
> 4. 네트워크 관련 기술(프로토콜 단위에서 IP주소, 포트 번호 같은 데이터를 비트로 분리해
>     네트워크와 호스트 부분에 대한 식별)
> 5. 임베디드 시스템(하드웨어 레지스터에 대한 조작)
>     등등 다양한 C언어 관련 기술에서 사용되는 핵심 기술 중 하나입니다.

<hr/>

# 2진수 계산법
+ 1. 계산할 값을 2의 제곱수로 분배합니다.
+ 2. 이때 2의 0제곱(1)도 범위에 포함합니다.
+ 3. 가장 큰 값부터 짤라냅니다.

<hr/>

# 제곱 수
+ 1 2 4 8 16 32 64 128
> 11 = 8 + 2 + 1  --> 1011
> 14 = 8 + 4 + 2      --> 1110

<hr/>

<hr/>

# 배열(Array)이란?
+ 배열이란 “같은 자료형”을 여러 개 연속해서 저장하기 위한 자료 구조입니다.
+ C언어에서 배열은 “배열명[인덱스]” 형태로 선언하며, 인덱스를 통해 각 요소에 접근할 수 있습니다.

<hr/>

# 1차원 배열
+ 1차원 배열은 가로로 길게 늘어선 상자들의 묶음이라고 생각하면 됩니다.
> 예시: int arr[8] = {0, 1, 2, 3, 4, 5, 6, 7};
>> arr[0]에는 0, arr[1]에는 1, … , arr[7]에는 7이 들어있습니다.
>> 배열 요소에 접근할 때는 arr[인덱스]를 사용합니다.
>> 인덱스는 0부터 시작하므로, 0~7까지 있습니다.

<hr/>

# 2차원 배열
+ 2차원 배열은 가로와 세로가 있는 표처럼 데이터를 저장하는 배열입니다.
> 예시: int arr2D[2][3] = 
> {
>> {1, 2, 3},
>> {4, 5, 6}
>> };
+ 여기서 arr2D[0][0] = 1, arr2D[1][2] = 6 과 같이, [행][열] 형태로 접근합니다.

<hr/>

# 배열의 길이(요소 개수) 구하기
+ C언어에서 배열의 크기(메모리 사용량)나 요소 개수를 알고 싶을 때는 sizeof라는 연산자를 씁니다.
+ 배열 전체의 메모리 크기: sizeof(배열이름)
+ 배열의 첫 번째 요소 크기: sizeof(배열이름[0])
+ 배열의 요소 개수:
> sizeof(배열이름) / sizeof(배열이름[0])
>> 예를 들어, arr가 int형 8개짜리 배열이면
>> sizeof(arr) / sizeof(arr[0]) // → 8 (요소 개수)
>> 2차원 배열이라면, 행과 열의 곱으로 요소 개수를 계산할 수 있습니다.

<hr/>

# ex 코드 설명

+ 1차원 배열 예시
int arr[8] = {0, 1, 2, 3, 4, 5, 6, 7};
printf("배열의 크기: %d\n", sizeof(arr));
printf("배열의 요소 개수: %d\n", sizeof(arr) / sizeof(arr[0]));
>> 크기: sizeof(arr) → 배열 전체 바이트 수
>> 요소 개수: sizeof(arr) / sizeof(arr[0])

<hr/>

+ 2차원 배열 예시
> int arr2D[2][3] = 
> {
>     {1, 2, 3},
>     {4, 5, 6}
> };
>> 2행 3열 → 요소 총 6개

<hr/>

+ 반복문으로 2차원 배열 출력
> for (int i = 0; i < 2; i++) 
> {
> for (int j = 0; j < 3; j++) 
> {
> printf("%d ", arr2D[i][j]);
> }
>  printf("\n");
> }
> i가 행, j가 열을 나타내며, 모든 칸을 순서대로 출력합니다.

<hr/>

+ 정리
> 배열은 같은 자료형의 데이터를 연속적으로 저장하는 구조이며, 인덱스로 각 요소에 접근합니다.
> 1차원 배열은 일렬로 늘어선 형태, 2차원 배열은 표처럼 행과 열로 구성됩니다.
> 배열의 요소에 접근할 때는 인덱스를 사용하며, 0부터 시작한다는 점을 기억하세요.
> sizeof 연산자를 사용해 배열의 전체 크기나 요소 개수를 구할 수 있습니다.

<hr/>

# 포인터의 활용 목적과 임베디드 프로그래밍
+ 포인터는 특히 임베디드 프로그래밍에서 많이 활용됩니다.

+ 주요 목적:
> 다양한 변수들에 대한 접근과 조작: 포인터를 사용하면 여러 형태의 변수에 직접 접근 및 수정할 수 있습니다.
> 효율적인 프로그램 작성: 메모리의 실제 위치를 다룸으로써 불필요한 복사나 오버헤드를 줄일 수 있습니다.
> 컴퓨터 동작 원리 이해: 메모리 구조와 주소 기반 연산을 직접 다루어, 하드웨어와의 밀접한 상호작용을 이해하는 데 도움이 됩니다.

+ 임베디드 프로그래밍:
> 하드웨어 제어를 위한 소프트웨어 개발에 있어, 포인터를 통해 메모리 맵에 직접 접근하거나, 특정 하드웨어 레지스터를 조작하는 것이 핵심입니다.
> 예시: 자동차, 냉장고, 스마트 워치 등 다양한 임베디드 시스템의 제어

<hr/>

# 포인터란 무엇인가?
+ 포인터는 메모리의 주소값을 저장하는 변수입니다.
+ 기본 개념:
> 일반 변수는 실제 데이터를 저장하지만, 포인터는 해당 데이터가 저장된 메모리 위치(주소)를 저장합니다.
> 예를 들어, int* ptr_value = &value;에서 ptr_value는 변수 value의 주소를 가리킵니다.

# 포인터의 주요 연산자
+ *(Asterisk) 연산자
+ 역할:
> 1. 곱셈 연산: 숫자끼리 곱셈을 수행할 때 사용합니다.
> 2. 포인터 선언 및 간접 참조:
> 2-1포인터 선언 시 자료형 뒤에 붙어 해당 변수가 포인터임을 명시합니다.
> 2-2간접 참조 연산자로 사용하면, 포인터가 가리키는 메모리 위치의 실제 값을 가져옵니다.

+ 예시:
> *ptr_value = 7; // 포인터를 통해 value의 값을 7로 변경
> printf("%d", *ptr_value); // value의 값 출력 (7)

+ &(Ampersand) 연산자
+ 역할:
+ 주소 연산자: 변수 앞에 사용하여 해당 변수의 메모리 주소를 반환합니다.
> 예: &value는 변수 value의 주소를 의미합니다.
+ 비트 연산: 값과 값 사이에서 비트 단위 AND 연산에 사용되지만, 포인터 관련 문맥에서는 주소 연산자로 사용됩니다.

# 단일 포인터와 메모리 접근
+ 단일 포인터는 특정 변수의 주소를 저장합니다.
> int value = 100;
> int* ptr_value = &value;

> 사용 예시:
> 초기에는 value의 값이 100이며, 포인터를 통해 값을 읽어올 수 있습니다.
> *ptr_value를 통해 간접적으로 value에 접근할 수 있고, 이를 수정하면 실제 변수의 값도 변경됩니다.
>>  value = 5;
>> printf("value 의 값: %d\n", value);         // 출력: 5
>> printf("ptr_value 의 값: %d\n", *ptr_value);   // 출력: 5

> *ptr_value = 7;
> printf("value 의 값: %d\n", value);           // 출력: 7

# 이중 및 삼중 포인터
포인터는 다른 포인터의 주소를 저장할 수 있으며, 이를 통해 다단계 간접 참조가 가능합니다.

+ 이중 포인터
+ 정의: 포인터 변수를 가리키는 포인터입니다.
> int** pptr_value = &ptr_value;
>> 사용:
>> *pptr_value는 ptr_value를 가리키며, **pptr_value는 ptr_value가 가리키는 변수(즉, value)의 값을 나타냅니다.

+ 삼중 포인터
+ 정의: 이중 포인터를 가리키는 포인터입니다.
> int*** ppptr_value = &pptr_value;
>> 사용:
>> ***ppptr_value를 사용하면, 최종적으로 value의 값(예제에서는 7)을 가져올 수 있습니다.

>> 확장성:
>> *의 개수를 늘려 n중 포인터로 확장할 수 있으나, 실무에서는 2중 포인터나 3중 포인터까지만 주로 사용됩니다.

<hr/>

# 함수
+ c언어 프로그램의 실행 단위를 의미합니다.
> 1. main()은 언어에서 프로그램 실행 시 처음 실행되도록 설정된 함수립니다.
> 2. 함수는 특정 하나의 기능을 수행하는 코드를 묶어서 하나의 명령어처럼 사용합니다.(ex.printf)
> 3. 사용자는 c언어에서 제공해주는 함수 이외에 사용자 정의 함수를 정의, 구현할 수 있습니다.
> 4. #include를 통해 라이브러리에서 제공해주는 헤더 파일을 코드에 연결해야 쓸 수있는 라이브러리 함수가 존재 합니다.

+ 함수 정의 형식(만드는방법)
> 반환타입 함수명(매개변수)
>> {
>> 함수를 호출했을 때, 실행할 명령문  => 반환타입 함수명(매개변수) , { 실행할 명령문; }
>> }
> 반환 타입: 함수가 실행된 후 반환할 값의 데이터 타입.
> 매개변수: 함수가 필요한 입력 값을 받기 위해 정의된 변수.
> return 키워드를 사용해 함수의 실행 결과를 반환하고 함수를 종료합니다.


+ add 함수
> 매개변수: int a, int b
> 기능: 두 매개변수의 합을 계산하여 반환합니다.
> 반환값: a와 b의 합

>> int add(int a, int b) {
>>    int result = a + b;
>>    return result;
>> }

+ sub 함수
> 매개변수: int a, int b
> 기능: 두 매개변수의 차를 계산하여 반환합니다.
> 반환값: a와 b의 차
>> int sub(int a, int b)
>> {
>> return a - b;
>> }

+ main 함수
> add 및 sub 함수를 호출하여 결과를 출력합니다.
> add(2, 7) 호출: a와 b의 값은 각각 2와 7, 결과는 9.
> sub(10, 5) 호출: a와 b의 값은 각각 10과 5, 결과는 5.
> printf 함수로 결과 출력: c와 d의 값 출력.


>> int main()
>> {
>> int c = add(2, 7);
>> int d = sub(10, 5);
>> printf("%d %d", c, d);
>> return 0;
>> }


# void 함수
> 반환 타입이 void인 함수를 의미합니다.
> 이 함수는 따로 return 값을 가지지 않습니다.

+ 예제: sample 함수
 void sample()
 {
  printf("Hello\n");
 }
-> Hello라는 문자열을 출력합니다.

# 매개변수를 가지는 함수
> 매개변수로 정수형 변수를 가지는 함수와 정수 포인터 변수를 가지는 함수로 나뉩니다.

+ 예제: add 함수
 void add(int a, int b)
 {
 int result = a + b;
 printf("result = %d \n", result);
 }
-> 두 정수 a와 b를 더한 결과를 출력합니다.

+ 예제: setAvalue 함수 (Call by Value)
> void setAvalue(int a, int value)
> {
> a = value;
> }
-> 정수형 변수 a에 value 값을 설정합니다.
-> 값에 의한 호출(Call by Value)이므로 함수 종료 후 원본 변수는 변경되지 않습니다.

+ 예제: setAvalue2 함수 (Call by Reference)
> void setAvalue2(int* a, int value)
> {
>   *a = value;
> }
-> 정수 포인터 변수 a가 가리키는 위치에 value 값을 설정합니다.
-> 참조에 의한 호출(Call by Reference)이므로 함수 종료 후 원본 변수도 변경됩니다.

# main 함수
+ 여러 함수 호출 예제를 포함하고 있습니다.
  
+ 예제: main 함수

> int main()
> {
> sample();
> add(1, 5);
> 
> int a = 7;
> setAvalue(a, 10);
> printf("a = %d\n", a); // 출력: a = 7
> 
> setAvalue2(&a, 10);
> printf("a = %d\n", a); // 출력: a = 10
> 
> return 0;
> }
-> sample() 함수를 호출하여 Hello를 출력합니다.
-> add(1, 5) 함수를 호출하여 1과 5를 더한 결과를 출력합니다.
-> setAvalue(a, 10) 함수를 호출하여 a의 값을 변경하려 하지만, 값에 의한 호출이므로 a의 값은 변경되지 않습니다.
-> setAvalue2(&a, 10) 함수를 호출하여 a의 값을 참조에 의한 호출로 변경합니다. 따라서 a의 값은 10으로 변경됩니다.
+ ∴ 값에 의한 호출(Call by Value): 함수 내부에서 값을 수정해도 원본 값은 변경되지 않습니다.
+ ∴ 참조에 의한 호출(Call by Reference): 함수 내부에서 값을 수정하면 원본 값도 변경됩니다.


# 가변 인자 함수
+ 헤더 파일 포함
> 가변 인자 함수를 사용하기 위해 #include <stdarg.h> 헤더 파일을 포함합니다.
  
+ 가변 인자 함수 정의
> printNumber 함수는 여러 개의 정수를 인자로 받아 출력합니다.
> 함수 정의 시 ...을 사용하여 가변 인자를 받도록 합니다.

+ 가변 인자 처리 절차
> 1. va_list args;를 선언하여 가변 인자 목록을 관리합니다.
> 2. va_start(args, count);로 가변 인자 목록을 초기화합니다. 여기서 count는 인자의 개수입니다.
> 3. va_arg(args, int);를 사용하여 가변 인자의 각각의 요소를 순차적으로 접근합니다.
> 4. va_end(args);로 가변 인자 처리를 종료합니다.

# 문자열 인자 처리
+ 문자열 인자를 받는 함수
> greeting 함수는 문자열 인자를 받아 환영 메시지를 출력합니다.
> char* name으로 문자열 인자를 받습니다.

#배열 인자 처리
+ 배열을 인자로 받는 함수
> printArray 함수는 정수 배열과 배열 크기를 인자로 받아 배열의 모든 요소를 출력합니다.
> printArrayptr 함수도 동일한 기능을 수행합니다.

+ 배열 출력
> for 반복문을 사용하여 배열의 각 요소를 출력합니다.

# 메인 함수
+ 가변 인자 함수 호출
> printNumber(5, 10, 20, 30, 40, 50);와 같이 다양한 개수의 정수를 출력합니다.
> printNumber(3, 5, 6, 7);로 또 다른 예시를 출력합니다.

+문자열 인자 함수 호출
> char name[] = "Grace";로 문자열을 선언하고, greeting(name);으로 출력합니다.

+ 배열 인자 함수 호출
> int arr[] = { 1, 2, 3, 4, 5 };로 배열을 선언하고,
> printArray(arr, 5);와 printArrayptr(arr, 5);로 배열의 요소를 출력합니다.

# 함수 연습문제 풀이

+ 2차 방정식 풀기:

X^2 - 2 = 2를 풀이하시오.
힌트: 2차 방정식을 풀기 위해선 근의 공식을 이용합니다.
해설: 2차 방정식은 보통 ax^2 + bx + c = 0 형태로 주어집니다. 여기서 a, b, c는 상수입니다. 근의 공식은 x = (-b ± sqrt(b^2 - 4ac)) / 2a 입니다. 이를 이용해 문제를 풉니다.

+ 순위 출력하기:

주어진 숫자에 순위에 맞는 접미사(st, nd, rd, th)를 붙여 출력합니다.
해설: 숫자 뒤에 붙는 접미사는 영어로 순위를 나타내는 방식입니다. 예를 들어, 1st, 2nd, 3rd, 4th와 같이 숫자에 따라 다르게 붙습니다.

+ 평균 구하기:

주어진 숫자들의 평균을 구하는 함수 average를 구현하세요.
힌트: printf를 활용하면 소수점 2자리까지 출력 가능.
해설: 평균은 주어진 숫자들의 합을 숫자의 개수로 나눈 값입니다. 이를 함수로 구현하여, 소수점 2자리까지 출력합니다.

+ 홀수 판별하기:

주어진 숫자가 홀수인지 판별하는 함수 isodd를 구현하세요.
해설: 숫자가 2로 나누어 떨어지지 않으면 홀수입니다. 예를 들어, 3은 홀수, 4는 짝수입니다.

+ 소수 판별하기:

주어진 숫자가 소수인지 판별하는 함수 getprime을 구현하세요.
해설: 소수는 1과 자기 자신 외에 약수가 없는 숫자입니다. 예를 들어, 2, 3, 5는 소수지만 4는 소수가 아닙니다.

#include <stdio.h>
#include <stdarg.h>
#include <math.h>

// 2차 방정식 근의 공식 함수
float Quadformula(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        printf("실근이 존재하지 않습니다.\n");
        return -1;
    } else {
        return (-b + sqrt(discriminant)) / (2 * a);
    }
}

// 순위 출력 함수
void printrank(int rank) {
    if (rank % 10 == 1 && rank != 11) {
        printf("%dst\n", rank);
    } else if (rank % 10 == 2 && rank != 12) {
        printf("%dnd\n", rank);
    } else if (rank % 10 == 3 && rank != 13) {
        printf("%drd\n", rank);
    } else {
        printf("%dth\n", rank);
    }
}

// 평균 구하는 함수
float average(int count, ...) {
    va_list args;
    va_start(args, count);
    int sum = 0;
    for (int i = 0; i < count; i++) {
        sum += va_arg(args, int);
    }
    va_end(args);
    return (float)sum / count;
}

// 홀수 판별 함수
void isodd(int num) {
    if (num % 2 != 0) {
        printf("YES\n");
    } else {
        printf("NO\n");
    }
}

// 소수 판별 함수
int getprime(int num) {
    if (num <= 1) return 0;
    for (int i = 2; i <= sqrt(num); i++) {
        if (num % i == 0) {
            return 0;
        }
    }
    return 1;
}

int main() {
    printf("root 4 %.2f\n", sqrt(4));

    double a = 1;
    double b = 2;
    double c = 3;
    float result = Quadformula(a, b, c);

    int rank = 1;
    printrank(rank);
    rank = 2;
    printrank(rank);
    rank = 3;
    printrank(rank);

    float result1 = average(3, 100, 95, 90);
    float result2 = average(4, 100, 95, 90, 90);
    printf("Average 1: %.2f\n", result1);
    printf("Average 2: %.2f\n", result2);

    isodd(3);
    isodd(4);
    isodd(5);

    for (int i = 1; i <= 10; i++) {
        if (getprime(i) == 1) {
            printf("%d는 소수입니다.\n", i);
        } else {
            printf("%d는 소수가 아닙니다.\n", i);
        }
    }

    return 0;
}






















[목차로](#목차)




